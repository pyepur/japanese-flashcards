<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kotoba Cards - Japanese Flashcards</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .japanese {
            font-family: 'Noto Sans JP', sans-serif;
        }
        /* --- Card Flip --- */
        .scene {
            perspective: 600px;
        }
        .card {
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .card.is-flipped {
            transform: rotateY(180deg);
        }
        .card__face {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        .card__face--back {
            transform: rotateY(180deg);
        }
        
        /* Hide scrollbar for all elements */
        ::-webkit-scrollbar {
            width: 0px;
            background: transparent; /* make scrollbar transparent */
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-4 bg-pink-50">

    <div id="app-container" class="w-full max-w-md mx-auto">

        <!-- ===== Deck Selection Screen ===== -->
        <div id="selection-screen" class="bg-white p-6 sm:p-8 rounded-2xl shadow-lg w-full transition-all text-center">
            <h2 class="text-3xl font-bold tracking-tight text-gray-900 japanese">ÂçòË™ûÂ∏≥„ÇíÈÅ∏„Å∂</h2>
            <p class="mt-1 text-lg text-gray-600">Select a Deck</p>
            <div id="deck-buttons-container" class="mt-6 space-y-3">
                <!-- Deck buttons will be dynamically inserted here -->
            </div>
            <div id="gid-error" class="hidden mt-4 text-center text-sm font-medium text-red-600 bg-red-50 p-3 rounded-lg"></div>
        </div>

        <!-- ===== Loading Screen (now hidden by default) ===== -->
        <div id="loading-screen" class="hidden bg-white p-6 sm:p-8 rounded-2xl shadow-lg w-full transition-all text-center">
            <svg class="mx-auto h-12 w-12 text-pink-500 animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18c-2.305 0-4.408.867-6 2.292m0-14.25v14.25" />
            </svg>
            <h2 class="mt-3 text-2xl font-bold tracking-tight text-gray-900 japanese">„Éá„ÉÉ„Ç≠„Çí„É≠„Éº„Éâ‰∏≠</h2>
            <p class="mt-1 text-base text-gray-600">Loading deck...</p>
            <div id="error-message" class="hidden mt-4 text-center text-sm font-medium text-red-600 bg-red-50 p-3 rounded-lg"></div>
            <div id="debug-headers" class="hidden mt-4 text-left text-xs text-gray-500 bg-gray-50 p-3 rounded-lg overflow-x-auto"></div>
        </div>

        <!-- ===== Study Screen ===== -->
        <div id="study-screen" class="hidden w-full transition-all">
            <!-- Header with Back Button and Progress Bar -->
            <div class="mb-4">
                <div class="flex justify-between items-center mb-2">
                    <button id="back-to-decks-study" class="text-sm font-medium text-pink-600 hover:text-pink-800 transition-colors">
                        &larr; Change Deck
                    </button>
                </div>
                
                <!-- NEW: Session Progress -->
                <div class="flex justify-between text-xs font-semibold text-gray-600 mb-1">
                    <span id="session-progress" class="text-left">Session: 0 / 0</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mb-2">
                    <div id="session-progress-bar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
                </div>

                <!-- Deck-wide Progress -->
                <div class="flex justify-between text-xs font-semibold text-pink-800 mb-1">
                    <span id="level-0-count">New: 0</span>
                    <span id="level-1-count">Learning: 0</span>
                    <span id="level-2-count">Familiar: 0</span>
                    <span id="level-3-count">Mastered: 0</span>
                </div>
                <div class="w-full bg-pink-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-pink-500 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
                </div>
            </div>

            <!-- Flashcard -->
            <div class="scene w-full h-80 sm:h-96">
                <div id="card" class="card relative w-full h-full">
                    <!-- Front (English / Base Form) -->
                    <div class="card__face card__face--front absolute w-full h-full bg-white rounded-2xl shadow-lg flex items-center justify-center p-6">
                        <div class="text-center space-y-2">
                            <!-- MODIFIED: Replaced card-front-text with two spans for more flexibility -->
                            <span id="card-front-main" class="block text-3xl sm:text-4xl font-bold text-gray-900 break-all japanese"></span>
                            <span id="card-front-sub" class="block text-2xl sm:text-3xl text-gray-700 japanese break-all"></span>
                        </div>
                    </div>
                    <!-- Back (Japanese / Te Form) -->
                    <div class="card__face card__face--back absolute w-full h-full bg-white rounded-2xl shadow-lg flex items-center justify-center p-6">
                        <div class="text-center space-y-2">
                            <span id="card-group" class="block text-sm font-semibold text-pink-500 japanese"></span>
                            <span id="card-kanji" class="block text-5xl sm:text-6xl font-bold text-gray-900 japanese break-all"></span>
                            <span id="card-hiragana" class="block text-2xl sm:text-3xl text-gray-700 japanese break-all"></span>
                            <span id="card-romaji" class="block text-xl text-gray-500"></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tap to Flip Message -->
            <p id="tap-to-flip" class="text-center text-gray-500 font-medium mt-4">Tap card to flip</p>

            <!-- Answer Buttons -->
            <div id="answer-buttons" class="hidden grid grid-cols-2 gap-4 mt-6">
                <button id="btn-struggled" class="w-full bg-white text-red-500 py-4 rounded-lg font-semibold text-base shadow-md border border-red-200 hover:bg-red-50 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300">
                    I Struggled
                </button>
                <button id="btn-known" class="w-full bg-white text-green-600 py-4 rounded-lg font-semibold text-base shadow-md border border-green-200 hover:bg-green-50 transition-colors focus:outline-none focus:ring-2 focus:ring-green-400">
                    I Knew It
                </button>
            </div>
        </div>
        
        <!-- ===== Completed Screen ===== -->
        <div id="completed-screen" class="hidden bg-white p-6 sm:p-10 rounded-2xl shadow-lg w-full text-center transition-all">
            <span class="text-6xl">üéâ</span>
            <h2 class="mt-4 text-3xl font-bold tracking-tight text-gray-900 japanese">„ÅäÁñ≤„ÇåÊßòÔºÅ</h2>
            <p class="mt-1 text-lg text-gray-600">Otsukaresama!</p>
            <p class="mt-4 text-base text-gray-500">
                You've mastered all the words in this deck.
            </p>
            <div class="mt-6 space-y-3">
                <button id="reset-deck" class="w-full bg-pink-500 text-white py-3 rounded-lg font-semibold text-sm shadow-md hover:bg-pink-600 transition-colors focus:outline-none focus:ring-2 focus:ring-pink-400 focus:ring-offset-2">
                    Study Again (Reset All)
                </button>
                <button id="back-to-decks-completed" class="w-full bg-white text-gray-700 py-3 rounded-lg font-semibold text-sm shadow-md border border-gray-200 hover:bg-gray-50 transition-colors focus:outline-none focus:ring-2 focus:ring-gray-300">
                    Change Deck
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- App Config ---
        const GOOGLE_SHEET_URL = "https://docs.google.com/spreadsheets/d/1vFXDC9uD2cIifk1kVjWcWk4ltaWAiANWJ9pC_qwNgYg/edit?usp=sharing";
        
        /**
         * --- HOW TO ADD NEW DECKS ---
         * 1. Go to your Google Sheet.
         * 2. Click on the tab you want to add (e.g., "„Å™ Adj").
         * 3. Look at the URL in your browser. Find the part that says "gid=...".
         * 4. Copy that number (the 'gid').
         * 5. Add a new line to the DECKS array below.
         */
        const DECKS = [
            { name: "Verbs", gid: '0' },
            { name: "„Å™ Adjectives", gid: '1583091929' },
            { name: "„ÅÑ Adjectives", gid: '1899131341' },
            // --- NEW: Special Te-Form Deck ---
            // This deck uses 'type' to tell the app to generate it
            // from the 'sourceGid' (your Verbs tab).
            { name: "Verbs (Te Form)", type: 'te-form', sourceGid: '0' }
        ];

        // --- NEW: Study Session Config ---
        const NEW_CARDS_PER_SESSION = 10; // Max new words to introduce in one batch

        // --- DOM Elements ---
        const selectionScreen = document.getElementById('selection-screen');
        const deckButtonsContainer = document.getElementById('deck-buttons-container');
        const gidError = document.getElementById('gid-error');
        
        const loadingScreen = document.getElementById('loading-screen');
        const studyScreen = document.getElementById('study-screen');
        const completedScreen = document.getElementById('completed-screen');
        const errorMessage = document.getElementById('error-message');
        const debugHeaders = document.getElementById('debug-headers');
        
        const card = document.getElementById('card');
        // MODIFIED: Replaced cardFrontText
        const cardFrontMain = document.getElementById('card-front-main');
        const cardFrontSub = document.getElementById('card-front-sub');
        
        const cardGroup = document.getElementById('card-group');
        const cardKanji = document.getElementById('card-kanji');
        const cardHiragana = document.getElementById('card-hiragana');
        const cardRomaji = document.getElementById('card-romaji');
        
        const tapToFlip = document.getElementById('tap-to-flip');
        const answerButtons = document.getElementById('answer-buttons');
        const btnStruggled = document.getElementById('btn-struggled');
        const btnKnown = document.getElementById('btn-known');
        
        const progressBar = document.getElementById('progress-bar');
        const level0Count = document.getElementById('level-0-count');
        const level1Count = document.getElementById('level-1-count');
        const level2Count = document.getElementById('level-2-count');
        const level3Count = document.getElementById('level-3-count');
        
        // NEW: Session progress elements
        const sessionProgress = document.getElementById('session-progress');
        const sessionProgressBar = document.getElementById('session-progress-bar');
        
        const resetDeckButton = document.getElementById('reset-deck');
        const backToDecksStudy = document.getElementById('back-to-decks-study');
        const backToDecksCompleted = document.getElementById('back-to-decks-completed');

        // --- App State ---
        let currentDeck = []; // The full deck of { english, japanese, ... } objects
        let studyQueue = []; // The words to be studied in this session
        let currentCard = null; // The word object currently on display
        let currentSheetId = null; // The Google Sheet ID
        let deckStorageKey = null; // Key for localStorage
        let isTeFormDeck = false; // NEW: Flag for Te-form deck logic

        // NEW: Session tracking
        let sessionTotal = 0;
        let sessionCardsDone = 0;

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', createDeckSelectionScreen); // Show selection on start
        card.addEventListener('click', flipCard);
        btnStruggled.addEventListener('click', () => handleAnswer(false));
        btnKnown.addEventListener('click', () => handleAnswer(true));
        resetDeckButton.addEventListener('click', resetCurrentDeck);
        backToDecksStudy.addEventListener('click', showSelectionScreen);
        backToDecksCompleted.addEventListener('click', showSelectionScreen);

        // --- Core Logic ---

        /**
         * --- ADDED: Flips the card when clicked. ---
         */
        function flipCard() {
            if (!currentCard) return; // Don't flip if no card
            
            card.classList.toggle('is-flipped');
            
            // Show/hide answer buttons
            if (card.classList.contains('is-flipped')) {
                tapToFlip.classList.add('hidden');
                answerButtons.classList.remove('hidden');
            } else {
                tapToFlip.classList.remove('hidden');
                answerButtons.classList.add('hidden');
            }
        }
        
        /**
         * --- ADDED: Handles the user's answer (Struggled or Knew It). ---
         */
        function handleAnswer(knewIt) {
            if (!currentCard) return;

            // 1. Update card level
            let currentLevel = currentCard.level;
            if (knewIt) {
                // Move up a level
                currentLevel = Math.min(currentLevel + 1, 3); // Max level is 3
            } else {
                // Move down a level
                currentLevel = Math.max(currentLevel - 1, 1); // Min level is 1 (Learning)
                // If it was New (0), it becomes 1. If it was Familiar (2), it becomes 1.
            }
            currentCard.level = currentLevel;

            // 2. Save progress
            saveDeckToStorage();
            
            // 3. Update session progress
            sessionCardsDone++;
            
            // 4. Update UI
            updateProgressUI();

            // 5. Check if session is over
            if (studyQueue.length === 0) {
                // Session is done, rebuild the queue
                startStudySession(); // This will either build a new session or go to Completed
            } else {
                // More cards in this session, show next card
                nextCard();
            }
        }

        /**
         * Custom error class to pass headers for debugging.
         */
        class ErrorWithHeaders extends Error {
            constructor(message, headers) {
                super(message);
                this.name = "ErrorWithHeaders";
                this.headers = headers;
            }
        }

        /**
         * NEW: Creates the deck selection buttons on the main screen.
         */
        function createDeckSelectionScreen() {
            deckButtonsContainer.innerHTML = ''; // Clear old buttons
            gidError.classList.add('hidden');
            
            DECKS.forEach(deck => {
                const button = document.createElement('button');
                button.className = "w-full bg-white text-pink-700 py-4 rounded-lg font-semibold text-lg shadow-md border border-pink-100 hover:bg-pink-50 transition-colors focus:outline-none focus:ring-2 focus:ring-pink-300";
                button.textContent = deck.name;
                button.onclick = () => handleDeckSelection(deck); // MODIFIED: Pass the whole deck object
                deckButtonsContainer.appendChild(button);
            });
            
            showSelectionScreen();
        }
        
        /**
         * NEW: Shows the selection screen and hides others.
         */
        function showSelectionScreen() {
            selectionScreen.classList.remove('hidden');
            loadingScreen.classList.add('hidden');
            studyScreen.classList.add('hidden');
            completedScreen.classList.add('hidden');
            
            // Reset state
            currentDeck = [];
            studyQueue = [];
            currentCard = null;
        }
        
        /**
         * NEW: Handles clicking a deck button.
         */
        function handleDeckSelection(deck) { // MODIFIED: Takes deck object
            if (!deck.gid && !deck.sourceGid) {
                gidError.textContent = 'This deck is not configured correctly.';
                gidError.classList.remove('hidden');
                return;
            }
            
            // NEW: Set Te-form flag and determine GID to load
            isTeFormDeck = (deck.type === 'te-form');
            const gid = isTeFormDeck ? deck.sourceGid : deck.gid;
            
            selectionScreen.classList.add('hidden');
            loadingScreen.classList.remove('hidden');
            gidError.classList.add('hidden');
            
            initializeApp(gid); // Load the selected/source deck
        }

        /**
         * MODIFIED: Initializes the app with a specific GID.
         */
        async function initializeApp(gid) {
            const { sheetId } = parseSheetUrl(GOOGLE_SHEET_URL);
            if (!sheetId) {
                showError("Invalid Google Sheet URL configured in the app.");
                return;
            }

            try {
                // 1. Fetch data
                const rawData = await fetchFromGoogleSheet(sheetId, gid);
                
                // 2. Parse data
                const words = parseSheetData(rawData);
                
                // 3. Initialize deck
                currentSheetId = sheetId;
                
                // --- NEW: Te-Form Deck Generation ---
                if (isTeFormDeck) {
                    // 1. Set a unique storage key for the Te-form deck
                    deckStorageKey = `kotobaDeck_${sheetId}_${gid}_teForm`;
                    // 2. Generate the new deck from the parsed verbs
                    const teDeck = generateTeFormDeck(words);
                    // 3. Load this new deck into state
                    loadDeckFromStorage(teDeck);
                } else {
                    // --- Original Path ---
                    // 1. Set the standard storage key
                    deckStorageKey = `kotobaDeck_${sheetId}_${gid}`;
                    // 2. Load the deck as-is
                    loadDeckFromStorage(words);
                }
                
                // 4. Start session (works for both deck types)
                startStudySession();
                
            } catch (error) {
                console.error("Error loading deck:", error);
                showError(error.message, error.headers);
            }
        }

        /**
         * MODIFIED: Parses the Google Sheet URL (now only needs sheetId).
         */
        function parseSheetUrl(url) {
            // Regex to find the sheet ID
            const sheetIdMatch = url.match(/\/d\/(.*?)\//);
            const sheetId = sheetIdMatch ? sheetIdMatch[1] : null;
            return { sheetId };
        }
        
        /**
         * Fetches the sheet data as JSON.
         * We add &headers=1 to tell the API that Row 1 is the header.
         */
        async function fetchFromGoogleSheet(sheetId, gid) {
            // MODIFIED: Added time parameter (_t) to prevent caching
            const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}&headers=1&_t=${Date.now()}`;
            
            console.log("Fetching from URL:", url);

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch sheet. Server responded with status: ${response.status}`);
                }
                let text = await response.text();
                
                // Clean the JSONP response
                const jsonMatch = text.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
                if (!jsonMatch || !jsonMatch[1]) {
                    throw new Error("Could not parse Google Sheet JSON response.");
                }
                
                const data = JSON.parse(jsonMatch[1]);
                
                if (data.status === 'error') {
                    throw new Error(`Google Sheet Error: ${data.errors.map(e => e.detailed_message).join(', ')}`);
                }
                
                return data;
                
            } catch (error) {
                console.error("Fetch error:", error);
                throw new Error(`Network error or issue fetching sheet: ${error.message}`);
            }
        }

        /**
         * Parses the JSON data from Google Sheets into our word format.
         * This now relies on the `&headers=1` API parameter.
         */
        function parseSheetData(data) {
            const words = [];
            const rows = data.table.rows;
            const cols = data.table.cols; // Headers are in the 'cols' array
            
            debugHeaders.classList.add('hidden'); // Hide debug info on new parse
            
            if (!cols || cols.length === 0) {
                throw new Error("Sheet has no columns or headers.");
            }
            if (!rows || rows.length === 0) {
                throw new Error("Sheet has headers but no data rows.");
            }

            // Read the headers from the 'cols' array (labels)
            // The 'id' is "A", "B", etc. The 'label' is our header name from Row 1.
            const headers = cols.map(col => (col.label || '').trim().toLowerCase());
            
            console.log("Detected Headers:", JSON.stringify(headers));
            
            // Helper function to find index from multiple possible names
            const findHeaderIndex = (possibleNames) => {
                for (const name of possibleNames) {
                    const index = headers.indexOf(name);
                    if (index > -1) {
                        return index;
                    }
                }
                return -1;
            };

            // Find column indices based on our template
            const englishIndex = findHeaderIndex(['english', 'meaning']);
            const japaneseIndex = findHeaderIndex(['hiragana', '„Å≤„Çâ„Åå„Å™', 'japanese', 'kana', 'reading', '„Çà„Åø']);
            const romajiIndex = findHeaderIndex(['romaji']);
            const kanjiIndex = findHeaderIndex(['kanji', 'Êº¢Â≠ó']);
            const groupIndex = findHeaderIndex(['group']);

            // Check for required columns
            if (englishIndex === -1 || japaneseIndex === -1) {
                console.error("Failed to find required columns. English index:", englishIndex, "Japanese index:", japaneseIndex);
                throw new ErrorWithHeaders(
                    'Sheet must have "English" and "Hiragana" (or "„Å≤„Çâ„Åå„Å™") columns in Row 1.',
                    headers
                );
            }
            
            console.log(`Column mapping: English(${englishIndex}), Japanese(${japaneseIndex}), Romaji(${romajiIndex}), Kanji(${kanjiIndex}), Group(${groupIndex})`);

            // Start from i=0 because 'rows' array is *only* data (no header)
            for (let i = 0; i < rows.length; i++) {
                const rowData = rows[i].c;
                // Check if row is null or undefined (can happen with empty rows)
                if (!rowData) continue;