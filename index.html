<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kotoba Cards - Japanese Flashcards</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      .japanese {
        font-family: "Noto Sans JP", sans-serif;
      }
      /* --- Card Flip --- */
      .scene {
        perspective: 600px;
      }
      .card {
        transition: transform 0.6s;
        transform-style: preserve-3d;
      }
      .card.is-flipped {
        transform: rotateY(180deg);
      }
      .card__face {
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }
      .card__face--back {
        transform: rotateY(180deg);
      }

      /* Hide scrollbar for all elements */
      ::-webkit-scrollbar {
        width: 0px;
        background: transparent; /* make scrollbar transparent */
      }
    </style>
  </head>
  <body class="h-full flex items-center justify-center p-4 bg-pink-50">
    <div
      id="app-container"
      class="w-full max-w-md mx-auto relative h-full flex flex-col justify-center"
    >
      <!-- ===== Deck Selection Screen ===== -->
      <div
        id="selection-screen"
        class="bg-white p-6 sm:p-8 rounded-2xl shadow-lg w-full transition-all text-center relative"
      >
        <h2 class="text-3xl font-bold tracking-tight text-gray-900 japanese">
          Vocabulary
        </h2>
        <p class="mt-1 text-lg text-gray-600">Select a Deck</p>
        <div id="deck-buttons-container" class="mt-6 space-y-3">
          <!-- Deck buttons will be dynamically inserted here -->
        </div>
        <div
          id="gid-error"
          class="hidden mt-4 text-center text-sm font-medium text-red-600 bg-red-50 p-3 rounded-lg"
        ></div>
      </div>

      <!-- NEW: Floating Action Button for Adding Words (Only visible on selection screen) -->
      <button
        id="fab-add-word"
        class="absolute bottom-6 right-6 bg-pink-500 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-3xl hover:bg-pink-600 transition-colors focus:outline-none focus:ring-2 focus:ring-pink-400 focus:ring-offset-2 z-10"
      >
        +
      </button>

      <!-- ===== NEW: Add Word Modal ===== -->
      <div
        id="add-word-modal"
        class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center p-4"
      >
        <div
          class="relative mx-auto p-6 border w-full max-w-sm shadow-lg rounded-2xl bg-white"
        >
          <h3 class="text-2xl font-bold text-gray-900 mb-4 japanese">
            ÂçòË™û„ÇíËøΩÂä†
          </h3>

          <form id="add-word-form" class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700"
                >English Meaning</label
              >
              <input
                type="text"
                id="input-english"
                required
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm p-2 border"
              />
            </div>

            <div>
              <label class="block text-sm font-medium text-gray-700 japanese"
                >Hiragana (Required)</label
              >
              <input
                type="text"
                id="input-hiragana"
                required
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm p-2 border"
                placeholder="e.g. „Åü„Åπ„Çã"
              />
            </div>

            <div>
              <label class="block text-sm font-medium text-gray-700 japanese"
                >Kanji (Optional)</label
              >
              <input
                type="text"
                id="input-kanji"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm p-2 border"
                placeholder="e.g. È£ü„Åπ„Çã"
              />
            </div>

            <div class="grid grid-cols-2 gap-4">
              <div>
                <label class="block text-sm font-medium text-gray-700"
                  >Type</label
                >
                <select
                  id="input-type"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm p-2 border"
                >
                  <option value="verb">Verb</option>
                  <option value="i-adj">„ÅÑ Adjective</option>
                  <option value="na-adj">„Å™ Adjective</option>
                  <option value="other">Other (Noun)</option>
                </select>
              </div>
              <div id="group-input-container">
                <label class="block text-sm font-medium text-gray-700"
                  >Verb Group</label
                >
                <select
                  id="input-group"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-500 focus:ring-pink-500 sm:text-sm p-2 border"
                >
                  <option value="1">Group 1 (u)</option>
                  <option value="2">Group 2 (ru)</option>
                  <option value="3">Group 3 (irreg)</option>
                </select>
              </div>
            </div>

            <div id="add-form-error" class="hidden text-red-500 text-sm"></div>
            <div id="add-form-success" class="hidden text-green-600 text-sm">
              Added successfully!
            </div>

            <div class="flex space-x-3 mt-6">
              <button
                type="button"
                id="cancel-add"
                class="flex-1 py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none"
              >
                Cancel
              </button>
              <button
                type="submit"
                id="submit-add"
                class="flex-1 py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-pink-600 hover:bg-pink-700 focus:outline-none"
              >
                Add Word
              </button>
            </div>
          </form>
        </div>
      </div>

      <!-- ===== Loading Screen (now hidden by default) ===== -->
      <div
        id="loading-screen"
        class="hidden bg-white p-6 sm:p-8 rounded-2xl shadow-lg w-full transition-all text-center"
      >
        <svg
          class="mx-auto h-12 w-12 text-pink-500 animate-pulse"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18c-2.305 0-4.408.867-6 2.292m0-14.25v14.25"
          />
        </svg>
        <h2
          class="mt-3 text-2xl font-bold tracking-tight text-gray-900 japanese"
        >
          „Éá„ÉÉ„Ç≠„Çí„É≠„Éº„Éâ‰∏≠
        </h2>
        <p class="mt-1 text-base text-gray-600">Loading deck...</p>
        <div
          id="error-message"
          class="hidden mt-4 text-center text-sm font-medium text-red-600 bg-red-50 p-3 rounded-lg"
        ></div>
        <div
          id="debug-headers"
          class="hidden mt-4 text-left text-xs text-gray-500 bg-gray-50 p-3 rounded-lg overflow-x-auto"
        ></div>
      </div>

      <!-- ===== Study Screen ===== -->
      <div id="study-screen" class="hidden w-full transition-all">
        <!-- Header with Back Button and Progress Bar -->
        <div class="mb-4">
          <div class="flex justify-between items-center mb-2">
            <button
              id="back-to-decks-study"
              class="text-sm font-medium text-pink-600 hover:text-pink-800 transition-colors"
            >
              &larr; Change Deck
            </button>
          </div>

          <!-- NEW: Session Progress -->
          <div
            class="flex justify-between text-xs font-semibold text-gray-600 mb-1"
          >
            <span id="session-progress" class="text-left">Session: 0 / 0</span>
          </div>
          <div class="w-full bg-gray-200 rounded-full h-2.5 mb-2">
            <div
              id="session-progress-bar"
              class="bg-blue-500 h-2.5 rounded-full transition-all duration-500"
              style="width: 0%"
            ></div>
          </div>

          <!-- Deck-wide Progress -->
          <div
            class="flex justify-between text-xs font-semibold text-pink-800 mb-1"
          >
            <span id="level-0-count">New: 0</span>
            <span id="level-1-count">Learning: 0</span>
            <span id="level-2-count">Familiar: 0</span>
            <span id="level-3-count">Mastered: 0</span>
          </div>
          <div class="w-full bg-pink-200 rounded-full h-2.5">
            <div
              id="progress-bar"
              class="bg-pink-500 h-2.5 rounded-full transition-all duration-500"
              style="width: 0%"
            ></div>
          </div>
        </div>

        <!-- Flashcard -->
        <div class="scene w-full h-80 sm:h-96">
          <div id="card" class="card relative w-full h-full">
            <!-- Front (English / Base Form) -->
            <div
              class="card__face card__face--front absolute w-full h-full bg-white rounded-2xl shadow-lg flex items-center justify-center p-6"
            >
              <div class="text-center space-y-2">
                <!-- MODIFIED: Replaced card-front-text with two spans for more flexibility -->
                <span
                  id="card-front-main"
                  class="block text-3xl sm:text-4xl font-bold text-gray-900 break-all japanese"
                ></span>
                <span
                  id="card-front-sub"
                  class="block text-2xl sm:text-3xl text-gray-700 japanese break-all"
                ></span>
              </div>
            </div>
            <!-- Back (Japanese / Te Form) -->
            <div
              class="card__face card__face--back absolute w-full h-full bg-white rounded-2xl shadow-lg flex items-center justify-center p-6"
            >
              <div class="text-center space-y-2">
                <span
                  id="card-group"
                  class="block text-sm font-semibold text-pink-500 japanese"
                ></span>
                <span
                  id="card-kanji"
                  class="block text-5xl sm:text-6xl font-bold text-gray-900 japanese break-all"
                ></span>
                <span
                  id="card-hiragana"
                  class="block text-2xl sm:text-3xl text-gray-700 japanese break-all"
                ></span>
                <span
                  id="card-romaji"
                  class="block text-xl text-gray-500"
                ></span>
              </div>
            </div>
          </div>
        </div>

        <!-- Tap to Flip Message -->
        <p id="tap-to-flip" class="text-center text-gray-500 font-medium mt-4">
          Tap card to flip
        </p>

        <!-- Answer Buttons -->
        <div id="answer-buttons" class="hidden grid grid-cols-2 gap-4 mt-6">
          <button
            id="btn-struggled"
            class="w-full bg-white text-red-500 py-4 rounded-lg font-semibold text-base shadow-md border border-red-200 hover:bg-red-50 transition-colors focus:outline-none focus:ring-2 focus:ring-red-300"
          >
            I Struggled
          </button>
          <button
            id="btn-known"
            class="w-full bg-white text-green-600 py-4 rounded-lg font-semibold text-base shadow-md border border-green-200 hover:bg-green-50 transition-colors focus:outline-none focus:ring-2 focus:ring-green-400"
          >
            I Knew It
          </button>
        </div>
      </div>

      <!-- ===== Completed Screen ===== -->
      <div
        id="completed-screen"
        class="hidden bg-white p-6 sm:p-10 rounded-2xl shadow-lg w-full text-center transition-all"
      >
        <span class="text-6xl">üéâ</span>
        <h2
          class="mt-4 text-3xl font-bold tracking-tight text-gray-900 japanese"
        >
          „ÅäÁñ≤„ÇåÊßòÔºÅ
        </h2>
        <p class="mt-1 text-lg text-gray-600">Otsukaresama!</p>
        <p class="mt-4 text-base text-gray-500">
          You've mastered all the words in this deck.
        </p>
        <div class="mt-6 space-y-3">
          <button
            id="reset-deck"
            class="w-full bg-pink-500 text-white py-3 rounded-lg font-semibold text-sm shadow-md hover:bg-pink-600 transition-colors focus:outline-none focus:ring-2 focus:ring-pink-400 focus:ring-offset-2"
          >
            Study Again (Reset All)
          </button>
          <button
            id="back-to-decks-completed"
            class="w-full bg-white text-gray-700 py-3 rounded-lg font-semibold text-sm shadow-md border border-gray-200 hover:bg-gray-50 transition-colors focus:outline-none focus:ring-2 focus:ring-gray-300"
          >
            Change Deck
          </button>
        </div>
      </div>
    </div>

    <script>
      console.log("Kotoba Cards App Starting...");

      // --- App Config ---
      const GOOGLE_SHEET_URL =
        "https://docs.google.com/spreadsheets/d/1vFXDC9uD2cIifk1kVjWcWk4ltaWAiANWJ9pC_qwNgYg/edit?usp=sharing";

      // *** CRITICAL: PASTE YOUR GOOGLE APPS SCRIPT WEB APP URL HERE ***
      const APPS_SCRIPT_URL =
        "https://script.google.com/macros/s/AKfycbxWgYcXkKRjkQz4U9pZ9ViuYUNOtOBTxSso7L2Ra4HwajadIOBpz8JCVzsOFz6usos/exec"; // e.g., "https://script.google.com/macros/s/AKfycbx.../exec"

      const DECKS = [
        { name: "Verbs", gid: "0" },
        { name: "„Å™ Adjectives", gid: "1583091929" },
        { name: "„ÅÑ Adjectives", gid: "1899131341" },
        { name: "Verbs (Te Form)", type: "te-form", sourceGid: "0" },
      ];

      const NEW_CARDS_PER_SESSION = 10;

      // --- DOM Elements ---
      const selectionScreen = document.getElementById("selection-screen");
      const deckButtonsContainer = document.getElementById(
        "deck-buttons-container"
      );
      const gidError = document.getElementById("gid-error");
      const loadingScreen = document.getElementById("loading-screen");
      const studyScreen = document.getElementById("study-screen");
      const completedScreen = document.getElementById("completed-screen");
      const errorMessage = document.getElementById("error-message");
      const debugHeaders = document.getElementById("debug-headers");
      const card = document.getElementById("card");
      const cardFrontMain = document.getElementById("card-front-main");
      const cardFrontSub = document.getElementById("card-front-sub");
      const cardGroup = document.getElementById("card-group");
      const cardKanji = document.getElementById("card-kanji");
      const cardHiragana = document.getElementById("card-hiragana");
      const cardRomaji = document.getElementById("card-romaji");
      const tapToFlip = document.getElementById("tap-to-flip");
      const answerButtons = document.getElementById("answer-buttons");
      const btnStruggled = document.getElementById("btn-struggled");
      const btnKnown = document.getElementById("btn-known");
      const progressBar = document.getElementById("progress-bar");
      const level0Count = document.getElementById("level-0-count");
      const level1Count = document.getElementById("level-1-count");
      const level2Count = document.getElementById("level-2-count");
      const level3Count = document.getElementById("level-3-count");
      const sessionProgress = document.getElementById("session-progress");
      const sessionProgressBar = document.getElementById(
        "session-progress-bar"
      );
      const resetDeckButton = document.getElementById("reset-deck");
      const backToDecksStudy = document.getElementById("back-to-decks-study");
      const backToDecksCompleted = document.getElementById(
        "back-to-decks-completed"
      );

      // --- NEW: Add Modal Elements ---
      const fabAddWord = document.getElementById("fab-add-word");
      const addWordModal = document.getElementById("add-word-modal");
      const addWordForm = document.getElementById("add-word-form");
      const cancelAddBtn = document.getElementById("cancel-add");
      const inputType = document.getElementById("input-type");
      const groupInputContainer = document.getElementById(
        "group-input-container"
      );
      const addFormError = document.getElementById("add-form-error");
      const addFormSuccess = document.getElementById("add-form-success");
      const submitAddBtn = document.getElementById("submit-add");

      // --- App State ---
      let currentDeck = [];
      let studyQueue = [];
      let currentCard = null;
      let currentSheetId = null;
      let deckStorageKey = null;
      let isTeFormDeck = false;
      let sessionTotal = 0;
      let sessionCardsDone = 0;

      // --- Event Listeners ---
      document.addEventListener("DOMContentLoaded", createDeckSelectionScreen);
      card.addEventListener("click", flipCard);
      btnStruggled.addEventListener("click", () => handleAnswer(false));
      btnKnown.addEventListener("click", () => handleAnswer(true));
      resetDeckButton.addEventListener("click", resetCurrentDeck);
      backToDecksStudy.addEventListener("click", showSelectionScreen);
      backToDecksCompleted.addEventListener("click", showSelectionScreen);

      // --- NEW: Add Word Event Listeners ---
      fabAddWord.addEventListener("click", () => {
        addWordModal.classList.remove("hidden");
        addFormSuccess.classList.add("hidden");
        addFormError.classList.add("hidden");
      });
      cancelAddBtn.addEventListener("click", () =>
        addWordModal.classList.add("hidden")
      );
      inputType.addEventListener("change", (e) => {
        // Show/Hide group input based on type
        if (e.target.value === "verb") {
          groupInputContainer.classList.remove("invisible");
        } else {
          groupInputContainer.classList.add("invisible");
        }
      });
      // Trigger change once on load to set initial state
      inputType.dispatchEvent(new Event("change"));

      addWordForm.addEventListener("submit", async (e) => {
        e.preventDefault();

        if (!APPS_SCRIPT_URL) {
          addFormError.textContent =
            "Error: Apps Script URL not configured in code.";
          addFormError.classList.remove("hidden");
          return;
        }

        const submitBtnOriginalText = submitAddBtn.textContent;
        submitAddBtn.textContent = "Adding...";
        submitAddBtn.disabled = true;
        addFormError.classList.add("hidden");
        addFormSuccess.classList.add("hidden");

        const data = {
          english: document.getElementById("input-english").value,
          hiragana: document.getElementById("input-hiragana").value,
          kanji: document.getElementById("input-kanji").value,
          type: document.getElementById("input-type").value,
          group: document.getElementById("input-group").value,
        };

        try {
          // We use 'no-cors' because Google Apps Script doesn't easily support CORS for simple POSTs.
          // This means we won't get a readable response back, but the data WILL be sent.
          await fetch(APPS_SCRIPT_URL, {
            method: "POST",
            mode: "no-cors",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });

          // Because of 'no-cors', we assume success if no network error was thrown.
          addFormSuccess.classList.remove("hidden");
          addWordForm.reset();
          // Reset dropdown visibility
          inputType.dispatchEvent(new Event("change"));

          // Auto-hide modal after 1.5s
          setTimeout(() => {
            addWordModal.classList.add("hidden");
            addFormSuccess.classList.add("hidden");
          }, 1500);
        } catch (error) {
          console.error("Error adding word:", error);
          addFormError.textContent =
            "Failed to add word. Check your connection.";
          addFormError.classList.remove("hidden");
        } finally {
          submitAddBtn.textContent = submitBtnOriginalText;
          submitAddBtn.disabled = false;
        }
      });

      // --- Core Logic (Previous functions remain mostly same) ---

      function flipCard() {
        if (!currentCard) return;
        card.classList.toggle("is-flipped");
        if (card.classList.contains("is-flipped")) {
          tapToFlip.classList.add("hidden");
          answerButtons.classList.remove("hidden");
        } else {
          tapToFlip.classList.remove("hidden");
          answerButtons.classList.add("hidden");
        }
      }

      function handleAnswer(knewIt) {
        if (!currentCard) return;
        let currentLevel = currentCard.level;
        if (knewIt) {
          currentLevel = Math.min(currentLevel + 1, 3);
        } else {
          currentLevel = Math.max(currentLevel - 1, 1);
        }
        currentCard.level = currentLevel;
        saveDeckToStorage();
        sessionCardsDone++;
        updateProgressUI();
        if (studyQueue.length === 0) {
          startStudySession();
        } else {
          nextCard();
        }
      }

      class ErrorWithHeaders extends Error {
        constructor(message, headers) {
          super(message);
          this.name = "ErrorWithHeaders";
          this.headers = headers;
        }
      }

      function createDeckSelectionScreen() {
        console.log("Creating Deck Selection Screen...");
        deckButtonsContainer.innerHTML = "";
        gidError.classList.add("hidden");
        DECKS.forEach((deck) => {
          const button = document.createElement("button");
          button.className =
            "w-full bg-white text-pink-700 py-4 rounded-lg font-semibold text-lg shadow-md border border-pink-100 hover:bg-pink-50 transition-colors focus:outline-none focus:ring-2 focus:ring-pink-300";
          button.textContent = deck.name;
          button.onclick = () => handleDeckSelection(deck);
          deckButtonsContainer.appendChild(button);
        });
        showSelectionScreen();
      }

      function showSelectionScreen() {
        selectionScreen.classList.remove("hidden");
        fabAddWord.classList.remove("hidden"); // Show ADD button
        loadingScreen.classList.add("hidden");
        studyScreen.classList.add("hidden");
        completedScreen.classList.add("hidden");
        currentDeck = [];
        studyQueue = [];
        currentCard = null;
      }

      function handleDeckSelection(deck) {
        console.log("Deck selected:", deck.name);
        if (!deck.gid && !deck.sourceGid) {
          gidError.textContent = "This deck is not configured correctly.";
          gidError.classList.remove("hidden");
          return;
        }
        isTeFormDeck = deck.type === "te-form";
        const gid = isTeFormDeck ? deck.sourceGid : deck.gid;
        selectionScreen.classList.add("hidden");
        fabAddWord.classList.add("hidden"); // Hide ADD button during study
        loadingScreen.classList.remove("hidden");
        gidError.classList.add("hidden");
        initializeApp(gid);
      }

      async function initializeApp(gid) {
        const { sheetId } = parseSheetUrl(GOOGLE_SHEET_URL);
        if (!sheetId) {
          showError("Invalid Google Sheet URL configured in the app.");
          return;
        }
        try {
          const rawData = await fetchFromGoogleSheet(sheetId, gid);
          const words = parseSheetData(rawData);
          currentSheetId = sheetId;
          if (isTeFormDeck) {
            deckStorageKey = `kotobaDeck_${sheetId}_${gid}_teForm`;
            const teDeck = generateTeFormDeck(words);
            loadDeckFromStorage(teDeck);
          } else {
            deckStorageKey = `kotobaDeck_${sheetId}_${gid}`;
            loadDeckFromStorage(words);
          }
          startStudySession();
        } catch (error) {
          console.error("Error loading deck:", error);
          showError(error.message, error.headers);
        }
      }

      function parseSheetUrl(url) {
        const sheetIdMatch = url.match(/\/d\/(.*?)\//);
        const sheetId = sheetIdMatch ? sheetIdMatch[1] : null;
        return { sheetId };
      }

      async function fetchFromGoogleSheet(sheetId, gid) {
        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}&headers=1&_t=${Date.now()}`;
        console.log("Fetching from URL:", url);
        try {
          const response = await fetch(url);
          if (!response.ok)
            throw new Error(
              `Failed to fetch sheet. Status: ${response.status}`
            );
          let text = await response.text();
          const jsonMatch = text.match(
            /google\.visualization\.Query\.setResponse\((.*)\);/s
          );
          if (!jsonMatch || !jsonMatch[1])
            throw new Error("Could not parse Google Sheet JSON response.");
          const data = JSON.parse(jsonMatch[1]);
          if (data.status === "error")
            throw new Error(
              `Google Sheet Error: ${data.errors
                .map((e) => e.detailed_message)
                .join(", ")}`
            );
          return data;
        } catch (error) {
          console.error("Fetch error:", error);
          throw new Error(
            `Network error or issue fetching sheet: ${error.message}`
          );
        }
      }

      function parseSheetData(data) {
        const words = [];
        const rows = data.table.rows;
        const cols = data.table.cols;
        debugHeaders.classList.add("hidden");
        if (!cols || cols.length === 0)
          throw new Error("Sheet has no columns or headers.");
        if (!rows || rows.length === 0)
          throw new Error("Sheet has headers but no data rows.");
        const headers = cols.map((col) =>
          (col.label || "").trim().toLowerCase()
        );
        console.log("Detected Headers:", JSON.stringify(headers));
        const findHeaderIndex = (possibleNames) => {
          for (const name of possibleNames) {
            const index = headers.indexOf(name);
            if (index > -1) return index;
          }
          return -1;
        };
        const englishIndex = findHeaderIndex(["english", "meaning"]);
        const japaneseIndex = findHeaderIndex([
          "hiragana",
          "„Å≤„Çâ„Åå„Å™",
          "japanese",
          "kana",
          "reading",
          "„Çà„Åø",
        ]);
        const romajiIndex = findHeaderIndex(["romaji"]);
        const kanjiIndex = findHeaderIndex(["kanji", "Êº¢Â≠ó"]);
        const groupIndex = findHeaderIndex(["group"]);
        if (englishIndex === -1 || japaneseIndex === -1) {
          console.error("Failed to find required columns.");
          throw new ErrorWithHeaders(
            'Sheet must have "English" and "Hiragana" columns in Row 1.',
            headers
          );
        }
        for (let i = 0; i < rows.length; i++) {
          const rowData = rows[i].c;
          if (!rowData) continue;
          if (
            rowData &&
            rowData[englishIndex] &&
            rowData[englishIndex].v &&
            rowData[japaneseIndex] &&
            rowData[japaneseIndex].v
          ) {
            const english = rowData[englishIndex].v.toString().trim();
            const japanese = rowData[japaneseIndex].v.toString().trim();
            const romaji =
              romajiIndex > -1 && rowData[romajiIndex] && rowData[romajiIndex].v
                ? rowData[romajiIndex].v.toString().trim()
                : "";
            const kanji =
              kanjiIndex > -1 && rowData[kanjiIndex] && rowData[kanjiIndex].v
                ? rowData[kanjiIndex].v.toString().trim()
                : "";
            const group =
              groupIndex > -1 && rowData[groupIndex] && rowData[groupIndex].v
                ? rowData[groupIndex].v.toString().trim()
                : "";
            if (english && japanese) {
              words.push({
                id: `${english}-${japanese}`,
                english: english,
                hiragana: japanese,
                kanji: kanji,
                romaji: romaji,
                group: group,
                level: 0,
              });
            }
          }
        }
        if (words.length === 0) throw new Error("No valid word rows found.");
        return words;
      }

      function getDictionaryForm(masuForm, group) {
        const stem = masuForm.slice(0, -2);
        if (!masuForm.endsWith("„Åæ„Åô")) return masuForm;
        if (group === "2") return stem + "„Çã";
        if (group === "3") {
          if (masuForm === "„Åç„Åæ„Åô") return "„Åè„Çã";
          if (masuForm.endsWith("„Åó„Åæ„Åô")) return stem + "„Åô„Çã";
          return masuForm;
        }
        if (group === "1") {
          const lastKanaOfStem = stem.slice(-1);
          const kanaStem = stem.slice(0, -1);
          switch (lastKanaOfStem) {
            case "„ÅÑ":
              return kanaStem + "„ÅÜ";
            case "„Åç":
              return kanaStem + "„Åè";
            case "„Åé":
              return kanaStem + "„Åê";
            case "„Åó":
              return kanaStem + "„Åô";
            case "„Å°":
              return kanaStem + "„Å§";
            case "„Å´":
              return kanaStem + "„Å¨";
            case "„Å≥":
              return kanaStem + "„Å∂";
            case "„Åø":
              return kanaStem + "„ÇÄ";
            case "„Çä":
              return kanaStem + "„Çã";
            default:
              return masuForm;
          }
        }
        return masuForm;
      }

      function calculateTeForm(dictionaryForm, group) {
        if (!dictionaryForm) return "";
        if (group === "2") return dictionaryForm.slice(0, -1) + "„Å¶";
        if (group === "3") {
          if (dictionaryForm === "„Åè„Çã") return "„Åç„Å¶";
          if (dictionaryForm.endsWith("„Åô„Çã"))
            return dictionaryForm.slice(0, -2) + "„Åó„Å¶";
          return dictionaryForm;
        }
        if (group === "1") {
          if (dictionaryForm === "„ÅÑ„Åè") return "„ÅÑ„Å£„Å¶";
          const lastKana = dictionaryForm.slice(-1);
          const stem = dictionaryForm.slice(0, -1);
          switch (lastKana) {
            case "„ÅÜ":
            case "„Å§":
            case "„Çã":
              return stem + "„Å£„Å¶";
            case "„ÇÄ":
            case "„Å∂":
            case "„Å¨":
              return stem + "„Çì„Åß";
            case "„Åè":
              return stem + "„ÅÑ„Å¶";
            case "„Åê":
              return stem + "„ÅÑ„Åß";
            case "„Åô":
              return stem + "„Åó„Å¶";
            default:
              return dictionaryForm;
          }
        }
        return dictionaryForm;
      }

      function generateTeFormDeck(verbDeck) {
        return verbDeck.map((verb) => {
          const dictionaryForm = getDictionaryForm(verb.hiragana, verb.group);
          const teForm = calculateTeForm(dictionaryForm, verb.group);
          return {
            id: `${verb.id}-te`,
            baseKanji: verb.kanji,
            baseHiragana: verb.hiragana,
            teForm: teForm,
            english: verb.english,
            group: verb.group,
            level: 0,
          };
        });
      }

      function getGroupText(group) {
        switch (group) {
          case "1":
            return "Group 1 (ikimasu)";
          case "2":
            return "Group 2 (emasu)";
          case "3":
            return "Group 3 (shimasu/kimasu)";
          default:
            return "";
        }
      }

      function loadDeckFromStorage(newWords) {
        let savedDeck = [];
        try {
          const savedData = localStorage.getItem(deckStorageKey);
          if (savedData) savedDeck = JSON.parse(savedData);
        } catch (e) {
          console.error("Failed to parse saved deck", e);
          savedDeck = [];
        }
        const savedWordMap = new Map(savedDeck.map((word) => [word.id, word]));
        currentDeck = newWords.map((newWord) => {
          const savedWord = savedWordMap.get(newWord.id);
          return savedWord ? { ...newWord, level: savedWord.level } : newWord;
        });
        saveDeckToStorage();
      }

      function saveDeckToStorage() {
        try {
          localStorage.setItem(deckStorageKey, JSON.stringify(currentDeck));
        } catch (e) {
          console.error("Failed to save deck", e);
          showError("Error saving progress. Storage might be full.");
        }
      }

      function resetCurrentDeck() {
        currentDeck.forEach((word) => (word.level = 0));
        saveDeckToStorage();
        startStudySession();
      }

      function startStudySession() {
        buildStudyQueue();
        if (studyQueue.length === 0) {
          showCompletedScreen();
          return;
        }
        loadingScreen.classList.add("hidden");
        completedScreen.classList.add("hidden");
        studyScreen.classList.remove("hidden");
        updateProgressUI();
        nextCard();
      }

      function showCompletedScreen() {
        loadingScreen.classList.add("hidden");
        studyScreen.classList.add("hidden");
        completedScreen.classList.remove("hidden");
      }

      function buildStudyQueue() {
        const level0 = currentDeck.filter((w) => w.level === 0);
        const level1 = currentDeck.filter((w) => w.level === 1);
        const level2 = currentDeck.filter((w) => w.level === 2);
        const reviewQueue = [...shuffleArray(level1), ...shuffleArray(level2)];
        const newWordsQueue = shuffleArray(level0).slice(
          0,
          NEW_CARDS_PER_SESSION
        );
        studyQueue = shuffleArray([...reviewQueue, ...newWordsQueue]);
        sessionTotal = studyQueue.length;
        sessionCardsDone = 0;
        console.log(
          `Study queue built: ${reviewQueue.length} review, ${newWordsQueue.length} new.`
        );
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function nextCard() {
        currentCard = studyQueue.shift();
        card.classList.remove("is-flipped");
        answerButtons.classList.add("hidden");
        tapToFlip.classList.remove("hidden");
        if (isTeFormDeck) {
          cardFrontMain.textContent = currentCard.baseKanji
            ? currentCard.baseKanji
            : currentCard.baseHiragana;
          if (currentCard.baseKanji) {
            cardFrontSub.textContent = currentCard.baseHiragana;
            cardFrontSub.classList.remove("hidden");
          } else {
            cardFrontSub.classList.add("hidden");
          }
          cardKanji.textContent = currentCard.teForm;
          cardHiragana.textContent = currentCard.english;
          cardHiragana.classList.remove("hidden");
          cardRomaji.classList.add("hidden");
          if (currentCard.group) {
            cardGroup.textContent = getGroupText(currentCard.group);
            cardGroup.classList.remove("hidden");
          } else {
            cardGroup.classList.add("hidden");
          }
        } else {
          cardFrontMain.textContent = currentCard.english;
          cardFrontSub.classList.add("hidden");
          cardKanji.textContent = currentCard.kanji
            ? currentCard.kanji
            : currentCard.hiragana;
          if (currentCard.kanji) {
            cardHiragana.textContent = currentCard.hiragana;
            cardHiragana.classList.remove("hidden");
          } else {
            cardHiragana.classList.add("hidden");
          }
          if (currentCard.romaji) {
            cardRomaji.textContent = currentCard.romaji;
            cardRomaji.classList.remove("hidden");
          } else {
            cardRomaji.classList.add("hidden");
          }
          if (currentCard.group) {
            cardGroup.textContent = getGroupText(currentCard.group);
            cardGroup.classList.remove("hidden");
          } else {
            cardGroup.classList.add("hidden");
          }
        }
      }

      function updateProgressUI() {
        const counts = { 0: 0, 1: 0, 2: 0, 3: 0 };
        currentDeck.forEach((word) => counts[word.level]++);
        level0Count.textContent = `New: ${counts[0]}`;
        level1Count.textContent = `Learning: ${counts[1]}`;
        level2Count.textContent = `Familiar: ${counts[2]}`;
        level3Count.textContent = `Mastered: ${counts[3]}`;
        const totalWords = currentDeck.length;
        if (totalWords === 0) {
          progressBar.style.width = "0%";
          return;
        }
        const progressPercent = (counts[3] / totalWords) * 100;
        progressBar.style.width = `${progressPercent}%`;
        sessionProgress.textContent = `Session: ${sessionCardsDone} / ${sessionTotal}`;
        const sessionPercent =
          sessionTotal > 0 ? (sessionCardsDone / sessionTotal) * 100 : 0;
        sessionProgressBar.style.width = `${sessionPercent}%`;
      }

      function showError(message, headers = []) {
        selectionScreen.classList.add("hidden");
        fabAddWord.classList.add("hidden");
        studyScreen.classList.add("hidden");
        completedScreen.classList.add("hidden");
        loadingScreen.classList.remove("hidden");
        errorMessage.textContent = message;
        errorMessage.classList.remove("hidden");
        if (headers && headers.length > 0) {
          debugHeaders.textContent = `Detected Headers: ${JSON.stringify(
            headers
          )}`;
          debugHeaders.classList.remove("hidden");
        } else {
          debugHeaders.classList.add("hidden");
        }
      }
    </script>
  </body>
</html>
